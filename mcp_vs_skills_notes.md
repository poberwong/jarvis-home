# MCP vs Skills：适用场景、区别与可迁移性

> 版本：Draft · 2026-02-20

## 一、MCP 适用场景（整理）
**1）通用/原子工具**
- 搜索、读取文档、执行 shell、执行 SQL 等
- 与系统提示词一起加载到上下文，**不可卸载**

**2）保留中间结果辅助 CoT**
- 需要保留推理 trace 与决策过程的任务
- 适合做成工具（MCP），方便在调用链中保留中间态

**3）污染 Context 的任务**
- 大量原文/数据的读取与导出，不需要 LLM 理解原文
- 适合用 MCP 直接处理，避免挤占对话上下文

**4）计算/数据处理**
- LLM 不擅长计算，需要代码来完成统计、分析、PDF 处理
- 适合 MCP：由工具执行代码，LLM 负责调度

---

## 二、Skills 适用场景（整理）
**1）风格指导类**
- 不需要调用工具，按固定格式输出内容
- 如：周报、规范代码生成、前端风格约束

**2）业务流程类（Workflow）**
- 有明确步骤、接口调用与依赖库
- 可按频率/复杂度拆分、按需渐进式加载
- 可调用其他 Skill 或工具

---

## 三、MCP vs Skills：区别与原理
| 维度 | MCP Server | Skill |
|------|------------|-------|
| 形态 | 可执行工具/服务 | 结构化流程/模板指令 |
| 调用方式 | Tool 调用（函数式） | Prompt + 步骤约束 |
| 上下文占用 | 低（工具处理数据） | 高（需文本描述流程） |
| 适用对象 | 原子能力、计算/数据处理 | 结构化业务流程、风格指导 |
| 可维护性 | 代码维护、版本升级 | 文档维护、规则迭代 |
| 适配性 | 强（跨项目复用） | 中（场景依赖强） |

**原理差异**：
- **MCP**：把能力封装为“可调用工具”，让 LLM 以函数调用方式执行；数据处理在工具侧完成。
- **Skill**：把流程封装为“操作说明/模板”，LLM 在上下文中理解后执行；工具只是辅助。

---

## 四、哪些 MCP 场景可转成 Skill
**可转成 Skill 的 MCP 场景：**
1) **标准化业务流程**：步骤明确、API 固定、输入输出可模板化
2) **风格一致的内容生成**：如报告、周报、PRD、固定格式文档
3) **低频但高价值流程**：不必常驻工具，可按需加载

**不适合转成 Skill 的 MCP 场景：**
- 大规模数据处理/计算任务
- 需要保持中间状态与工具输出的复杂流程
- 原子工具类（搜索、SQL、系统命令）

---

## 五、结论（浓缩）
- **MCP = 工具化能力**（重执行、轻上下文）
- **Skill = 流程化能力**（重提示、轻执行）
- 大多数“业务流程”都可以从 MCP 迁移成 Skill，但涉及计算/大数据/原子工具则更适合保留 MCP
